"""
@author: Yonas Gebregziabher, CSCI 3725, M7: Poetry Slam

This represents a Villanelle Poem object as well
the functionalities to generate / evaluate stanzas and lines for
each stanzas.
"""
from typing import List
from .model import SemanticSearchModel
from .lang_utility import LanguageUtility
from .stanza import Stanza
from utils.data_cleaner import get_lyrics
import random
import re

SELECT_FROM_TOP_K = 2  # top k lyric matches to pick from


class VillanellePoem:

    def __init__(self, inspiring_object_queries: List[str], lang_utility: LanguageUtility,
                 smtic_model: SemanticSearchModel) -> None:
        "Initializes the VillanellePoem object"
        self.inspiring_object_queries = inspiring_object_queries
        self.lang_utility = lang_utility
        self.smtic_model = smtic_model
        self.stanzas: List[Stanza] = []
        self.A_PATTERN = None
        self.B_PATTERN = None
        self.inspiration_lyrics = set()
        self.used_rhymes = set()

    def get_inspiring_object_queries(self) -> List[str]:
        "Return the list of queries used to generate stanzas"
        return self.inspiring_object_queries

    def get_all_poem_lines(self) -> List[str]:
        "Returns all of the poem lines"
        lines = []
        for stanza in self.stanzas:
            lines.extend(stanza.get_all_lines())
        return [line for line in lines if len(line.strip()) > 0]

    def get_inspiration_lyrics(self) -> List[str]:
        "Return the list of lyrics used to generate lines"
        return self.inspiration_lyrics

    def add_stanza(self, stanza: Stanza) -> bool:
        "Adds a stanza to the list of stanzas"
        self.stanzas.append(stanza)

    def calculate_rhyme_percentage(self) -> float:
        """
        Returns the percentage of the poem that follows the 
        Villanelle rhyme structure and punishes for repeated
        usage of rhyming words.
        """
        lines = self.get_all_poem_lines()
        rhyme_count = 0
        total_lines = len(lines)
        a_lines = [0, 2, 3, 5, 6, 8, 9, 11, 12, 14, 15, 17, 18]
        b_lines = [1, 4, 7, 10, 13, 16]

        for a_idx in a_lines:
            line = lines[a_idx]
            last_word = line.split(" ")[-1]
            if self.lang_utility.does_rhyme(last_word, self.A_PATTERN):
                rhyme_count += 1

        for b_idx in b_lines:
            line = lines[b_idx]
            last_word = line.split(" ")[-1]
            if self.lang_utility.does_rhyme(last_word, self.B_PATTERN):
                rhyme_count += 1

        # duplicate rhymes should be punished
        rhyme_count -= (total_lines - 6) - \
            len(self.used_rhymes)  # line that should repeat
        rhyme_percentage = (rhyme_count / total_lines) * 100
        return rhyme_percentage

    def calc_insp_similarity(self) -> float:
        "Calculates word usage similarity to inspiration lines"
        poem_lines = self.get_all_poem_lines()
        inspo_lines = list(self.get_inspiration_lyrics())
        similarities = []
        for inspo, poem in zip(inspo_lines, poem_lines):
            inspo_words = inspo.split()
            poem_words = poem.split()

            # Calc % similarity bn each word
            similarity = sum(a == b for a, b in zip(inspo_words, poem_words)
                             ) / max(len(inspo_words), len(poem_words)) * 100
            similarities.append(similarity)

        return sum(similarities) / len(similarities)

    def calc_img_similarity(self) -> float:
        """
        Calculates how well the poem captured the image by measuring
        embedding distance between the poem and the queries
        generated by the list of object from the image. 
        """
        poem_lines = " ".join(self.get_all_poem_lines())
        img_insp_objs = " ".join(self.get_inspiring_object_queries())
        return self.smtic_model.get_similarity_score(poem_lines, img_insp_objs)

    def clean_sentence(self, sentence: str) -> str:
        "Removes unwanted characters/spaces from end of line"
        cleaned_sentence = re.sub(r'\s*([^a-zA-Z\s]+)?$', '', sentence)
        return cleaned_sentence

    def select_kth_modifier(self, lyric_matches: str, k: int) -> str:
        """
        Selects a random replacement from top k element this increases
        variations in poems from the same image
        """
        slice_idx = min(k, len(lyric_matches))
        return random.choice(lyric_matches[:slice_idx])

    def reset(self):
        """
        Resets the poem object without destroying the class so we don't have
        to reload the models.
        """
        self.A_PATTERN = None
        self.B_PATTERN = None
        self.used_rhymes = set()
        self.inspiration_lyrics = set()
        self.stanzas = []

    def search_inspired_match(self, inspiring_line: str, rhyme_pattern: str,
                              k: int = 25) -> str:
        """
        Searches for a lyrics that are similar to the inspiration and
        modifies the sentences to fit the desired rhyme pattern. It also
        adds the inspiration lyrics to the set and update the used_rhymes set
        as well.
        """
        line_length = len(inspiring_line.split(" "))
        target_length = random.randint(
            max(1, line_length - 1), line_length + 1)
        matches = self.smtic_model.search(
            query=inspiring_line, k=k, target_len=target_length,
            already_used_lines=self.inspiration_lyrics)
        replacement_match = self.select_kth_modifier(
            matches, SELECT_FROM_TOP_K)
        if replacement_match in self.inspiration_lyrics:
            replacement_match = random.choice(get_lyrics())
        modified_sentence = self.lang_utility.modify_sentence(
            poem_line=replacement_match, rhyme_pattern=rhyme_pattern, used_rhymes=self.used_rhymes)

        clean_modified_sentence = self.clean_sentence(modified_sentence)
        # inspiration for evaluation
        self.inspiration_lyrics.add(replacement_match)
        used_rhyme = clean_modified_sentence.split(" ")[-1]
        self.used_rhymes.add(used_rhyme)
        return clean_modified_sentence

    def gen_first_stanza(self, inspiring_q: str, k: int = 25) -> bool:
        "Generates the first stanza of the poem"
        stanza = Stanza(1)
        print("Generating stanza 1")
        # first line
        matching_a_line = self.search_inspired_match(
            inspiring_q, None, k)
        self.A_PATTERN = matching_a_line.split(" ")[-1]
        stanza.add_line(matching_a_line)
        # second line
        b_matching_line = self.search_inspired_match(
            matching_a_line, None, k)
        self.B_PATTERN = b_matching_line.split(" ")[-1]
        stanza.add_line(b_matching_line)
        # third line
        a_match_3 = self.search_inspired_match(
            b_matching_line, self.A_PATTERN, k)
        stanza.add_line(a_match_3)
        self.stanzas.append(stanza)
        return True

    def generate_stanzas(self) -> bool:
        "Generates the remaining A-B pairs"
        num_of_inspiring_object_queries = len(self.inspiring_object_queries)
        curr_inspo_obj_idx = 1

        for i in range(2, 7):  # stanzas 2 - 6
            stanza = Stanza(i)
            print(f"Generating stanza {i}")
            query = None
            if curr_inspo_obj_idx < num_of_inspiring_object_queries:
                query = self.inspiring_object_queries[curr_inspo_obj_idx]
                curr_inspo_obj_idx += 1
            else:
                query = random.choice(get_lyrics())
            curr_inspo_obj_idx += 1
            a_line = self.search_inspired_match(
                inspiring_line=query, rhyme_pattern=self.A_PATTERN, k=25)
            stanza.add_line(a_line)
            b_line = self.search_inspired_match(
                inspiring_line=a_line, rhyme_pattern=self.B_PATTERN, k=25)
            stanza.add_line(b_line)
            self.stanzas.append(stanza)
        return True

    def complete_villanelle(self) -> None:
        "Adds the duplicate lines to the stanzas"
        line_1 = self.stanzas[0].get_line(0)
        line_3 = self.stanzas[0].get_line(2)
        self.stanzas[1].add_line(line_1)  # second_stanza
        self.stanzas[2].add_line(line_3)  # third_stanza
        self.stanzas[3].add_line(line_1)  # fourth_stanza
        self.stanzas[4].add_line(line_3)  # fifth stanza
        self.stanzas[5].add_line(line_1)  # sixth a
        self.stanzas[5].add_line(line_3)  # sixth b

    def gen_full_poem(self) -> None:
        "Generate an entire poem"
        self.reset()
        self.gen_first_stanza(self.inspiring_object_queries[0])
        self.generate_stanzas()
        self.complete_villanelle()

    def __str__(self) -> str:
        "Get a string representation of the poem"
        str_rep = ""
        for stanza in self.stanzas:
            str_rep += str(stanza) + "\n"
        print("Calculating Evaluation Scores .... \n")
        str_rep += f"Rhyme score: {self.calculate_rhyme_percentage():2f}%\n"
        str_rep += f"Similarity to inspo lyrics: {self.calc_insp_similarity():2f}%\n"
        str_rep += f"Similarity to input image/concepts : {self.calc_img_similarity():2f}%"
        return str_rep
